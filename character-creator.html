<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neka Character Creator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
         
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: 100%;
            overflow: hidden;
        }

        .header {
            background: #5db5ef;
            color: white;
            padding: 20px 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 5px;
        }

        .header p {
            opacity: 0.9;
            font-size: 14px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1000px;
            gap: 20px;
            padding: 30px;
        }

        .canvas-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        #character-canvas {
            border: 3px solid #e0e0e0;
            border-radius: 15px;
            background:
                repeating-conic-gradient(#f0f0f0 0% 25%, white 0% 50%) 50% / 20px 20px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .kit-selector-area {
            margin-bottom: 5px;
        }

        #kit-selector {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ddd;
            background: #f9f9f9;
            font-size: 14px;
            color: #333;
            outline: none;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        #kit-selector:focus {
            border-color: #667eea;
        }

        .part-navigation {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 15px;
        }

        .part-navigation h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 16px;
        }

        .nav-icons {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 10px;
        }

        .nav-icon {
            width: 50px;
            aspect-ratio: 1;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            overflow: hidden;
            background: white;
            position: relative;
        }

        .nav-icon img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .nav-icon:hover {
            border-color: #667eea;
            transform: scale(1.05);
        }

        .nav-icon.active {
            border-color: #667eea;
            border-width: 3px;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        .nav-icon .label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 10px;
            padding: 2px;
            text-align: center;
        }

        .item-selector {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .item-selector h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 16px;
        }

        .item-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 10px;
        }

        .item-option {
            aspect-ratio: 1;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            overflow: hidden;
            background: white;
            position: relative;
        }

        .item-option img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .item-option:hover {
            border-color: #667eea;
            transform: scale(1.05);
        }

        .item-option.active {
            border-color: #667eea;
            border-width: 3px;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        .item-none {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            color: #ccc;
            font-weight: 300;
            background: #fdfdfd !important;
        }

        .item-none::before {
            content: "‚úï";
        }

        .color-selector {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 15px;
        }

        .color-selector h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 16px;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
            gap: 8px;
        }

        .color-option {
            aspect-ratio: 1;
            border: 2px solid #e0e0e0;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.active {
            border-color: #667eea;
            border-width: 3px;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        @media (max-width: 968px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        .container-full{
            width: 100%;
        }
    </style>
</head>

<body>
    <div class="container-full">
        <div class="header">
            <h1>Test Neka Character Creator</h1>
            <p></p>
        </div>

        <div class="main-content">
            <div class="canvas-area">
                <canvas id="character-canvas" width="400" height="400"></canvas>
                <div class="controls">
                    <button class="btn btn-secondary" onclick="randomizeCharacter()">üé≤ Random</button>
                </div>
            </div>

            <div class="sidebar">
                <div class="kit-selector-area">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                        <h3>B·ªô s∆∞u t·∫≠p</h3>
                        <button class="btn" style="background: #667eea; color: white; padding: 5px 10px; font-size: 12px;" onclick="promptZipKit()">üì¶ Data (ZIP)</button>
                    </div>
                    <select id="kit-selector" onchange="switchKit(this.value)">
                        <option value="">ƒêang t·∫£i danh s√°ch...</option>
                    </select>
                </div>

                <div class="part-navigation">
                    <h3>Ch·ªçn b·ªô ph·∫≠n <span id="count-layer"></span></h3>
                    <div class="nav-icons" id="nav-icons"></div>
                </div>

                <div class="item-selector">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 id="current-part-name">Ch·ªçn m·ªôt b·ªô ph·∫≠n</h3>
                        <button id="delete-part-btn" class="btn" style="background: #ff7675; color: white; padding: 5px 10px; font-size: 12px; display: none;" onclick="promptDeletePart()">üóëÔ∏è X√≥a b·ªô ph·∫≠n n√†y</button>
                    </div>
                    <div class="item-grid" id="item-grid"></div>
                </div>

                <div class="color-selector">
                    <h3>Ch·ªçn m√†u</h3>
                    <div class="color-grid" id="color-grid"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        let KIT_BASE_PATH = 'downloads/';
        let CURRENT_KIT_FOLDER = ''; // Set dynamically
        let KIT_PATH = ''; // Set dynamically

        // State
        let kitStructure = null; // Changed from metadata
        let kits = [];
        let currentPart = null;
        let currentItem = null;
        let currentColor = null;
        let currentColorIndex = 0;
        let characterLayers = {};

        // Canvas
        const canvas = document.getElementById('character-canvas');
        const ctx = canvas.getContext('2d');

        // Load Kits list
        async function loadKitsList() {
            try {
                const response = await fetch('kits.json');
                kits = await response.json();

                if (kits.length > 0) {
                    // Auto-select the first kit
                    const firstKit = kits[0];
                    CURRENT_KIT_FOLDER = firstKit.folder;
                    KIT_PATH = `${KIT_BASE_PATH}${CURRENT_KIT_FOLDER}/items_structured/`;
                }

                const selector = document.getElementById('kit-selector');
                selector.innerHTML = '';

                kits.forEach(kit => {
                    const option = document.createElement('option');
                    option.value = kit.folder;
                    option.textContent = kit.name;
                    if (kit.folder === CURRENT_KIT_FOLDER) option.selected = true;
                    selector.appendChild(option);
                });

                loadKitStructure();
            } catch (error) {
                console.error('Error loading kits list:', error);
                // Fallback to current hardcoded kit if kits.json fails
                loadKitStructure();
            }
        }

        // Switch Kit
        function switchKit(folderName) {
            if (!folderName) return;

            CURRENT_KIT_FOLDER = folderName;
            KIT_PATH = `${KIT_BASE_PATH}${CURRENT_KIT_FOLDER}/items_structured/`;

            // Clear current kit structure to trigger fresh load
            kitStructure = null;
            
            // Reset character UI
            resetCharacter();

            // Reload kit structure for new kit
            loadKitStructure();
        }

        // Load kit structure from folder API
        async function loadKitStructure() {
            try {
                const response = await fetch('/api/get_kit_structure', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ kit: CURRENT_KIT_FOLDER })
                });
                const result = await response.json();
                if (result.success) {
                    kitStructure = result.parts;
                    initializeApp();
                } else {
                    console.error('Error loading kit structure:', result.message);
                }
            } catch (error) {
                console.error('Error loading kit structure:', error);
            }
        }

        // Initialize app
        function initializeApp() {
            if (!kitStructure || kitStructure.length === 0) {
                console.error('No kit structure loaded');
                return;
            }

            const navContainer = document.getElementById('nav-icons');
            const countLayer = document.getElementById('count-layer');
            navContainer.innerHTML = '';
            countLayer.innerHTML = '';
            kitStructure.forEach((part, index) => {
              
                
                const navIcon = document.createElement('div');
                navIcon.className = 'nav-icon';
                navIcon.dataset.partIndex = index;
                navIcon.dataset.folderName = part.folder;

                const img = document.createElement('img');
                img.src = `${KIT_PATH}${part.folder}/nav.png`;
                img.alt = part.folder;
                img.onerror = () => img.style.display = 'none';

                const label = document.createElement('div');
                label.className = 'label';
                label.textContent = part.folder;

                navIcon.appendChild(img);
                navIcon.appendChild(label);
                navIcon.onclick = () => selectPart(index, part);

                navContainer.appendChild(navIcon);
                countLayer.textContent = `(${kitStructure.length})`;
                // Auto-select first item for this part by default
                if (part.items_count > 0) {
                    const firstColor = part.colors.length > 0 ? part.colors[0] : 'default';
                    internalSelectItem(index, 1, part, firstColor, 0);
                }
            });

            // Select first part in UI
            if (kitStructure.length > 0) {
                selectPart(0, kitStructure[0]);
            }
        }

        // Internal select item for auto-init
        async function internalSelectItem(partIndex, itemNumber, part, colorCode, colorIndex) {
            const sortOrder = part.x * 1000 + partIndex;

            characterLayers[partIndex] = {
                folderName: part.folder,
                color: colorCode,
                colorIndex: colorIndex,
                itemNumber: itemNumber,
                sortOrder: sortOrder
            };
            renderCharacter();
        }

        // Select part
        function selectPart(index, part) {
            currentPart = { index, part };

            // Update active nav icon
            document.querySelectorAll('.nav-icon').forEach(icon => {
                icon.classList.remove('active');
            });
            document.querySelector(`[data-part-index="${index}"]`).classList.add('active');

            // Update part name
            document.getElementById('current-part-name').textContent = part.folder;
            document.getElementById('delete-part-btn').style.display = 'block';

            // Reset item to 1 for new part
            currentItem = 1;

            // Load items
            loadItems(part);

            // Load colors
            loadColors(part);
        }

        // Load items for current part
        async function loadItems(part) {
            const itemGrid = document.getElementById('item-grid');
            itemGrid.innerHTML = '<div class="loading"><div class="spinner"></div>ƒêang t·∫£i...</div>';

            itemGrid.innerHTML = '';

            // Add "None" option
            const noneDiv = document.createElement('div');
            noneDiv.className = 'item-option item-none';
            if (characterLayers[currentPart.index] === undefined) {
                noneDiv.classList.add('active');
            }
            noneDiv.onclick = () => selectItem(-1);
            itemGrid.appendChild(noneDiv);

            // Generate items from 1 to items_count
            for (let itemNum = 1; itemNum <= part.items_count; itemNum++) {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'item-option';
                itemDiv.dataset.itemNumber = itemNum;

                if (characterLayers[currentPart.index] && characterLayers[currentPart.index].itemNumber === itemNum) {
                    itemDiv.classList.add('active');
                }

                const img = document.createElement('img');
                const imagePath = `${KIT_PATH}${part.folder}/thumb_${itemNum}.png`;
                img.src = imagePath;
                img.onerror = () => {
                    console.log(`Thumbnail not found: ${imagePath}`);
                    itemDiv.style.display = 'none';
                };

                itemDiv.appendChild(img);
                itemDiv.onclick = () => selectItem(itemNum);

                itemGrid.appendChild(itemDiv);
            }
        }

        // Helper to extract hex color from folder name
        function getColorHex(colorFolderName) {
            if (colorFolderName === 'default') return 'CCCCCC';
            // Extract hex from folder name (e.g., "FF5733" or "FF5733_2")
            const match = colorFolderName.match(/^([0-9A-Fa-f]{6})/);
            return match ? match[1] : 'CCCCCC';
        }

        // Load colors
        async function loadColors(part) {
            const colorGrid = document.getElementById('color-grid');
            colorGrid.innerHTML = '';

            const colors = part.colors.length > 0 ? part.colors : ['default'];

            colors.forEach((colorFolder, index) => {
                const colorDiv = document.createElement('div');
                colorDiv.className = 'color-option';
                colorDiv.dataset.colorIndex = index;
                colorDiv.dataset.colorFolder = colorFolder;

                const hexColor = getColorHex(colorFolder);
                colorDiv.style.background = `#${hexColor}`;
                colorDiv.title = colorFolder === 'default' ? 'M√†u m·∫∑c ƒë·ªãnh' : `#${hexColor}`;

                if (colorFolder === 'default') {
                    colorDiv.classList.add('default-color');
                }

                colorDiv.onclick = () => selectColor(colorFolder, index);

                colorGrid.appendChild(colorDiv);
            });

            // Select first color by default
            if (colors.length > 0) {
                selectColor(colors[0], 0);
            }
        }

        // Select item
        function selectItem(itemNumber) {
            currentItem = itemNumber;

            document.querySelectorAll('.item-option').forEach(item => {
                item.classList.remove('active');
            });
            
            if (itemNumber === -1) {
                // "None" selected
                document.querySelector('.item-none')?.classList.add('active');
                delete characterLayers[currentPart.index];
                renderCharacter();
                return;
            }

            document.querySelector(`[data-item-number="${itemNumber}"]`)?.classList.add('active');

            // Auto-select first color if not already selected
            if (!currentColor) {
                const firstColorOption = document.querySelector('.color-option');
                if (firstColorOption) {
                    const firstColorFolder = firstColorOption.dataset.colorFolder;
                    selectColor(firstColorFolder, 0);
                }
            } else {
                // Update with current color
                updateCharacter();
            }
        }

        // Select color
        function selectColor(colorFolder, colorIndex) {
            currentColor = colorFolder;
            currentColorIndex = colorIndex !== undefined ? colorIndex : 0;

            document.querySelectorAll('.color-option').forEach(color => {
                color.classList.remove('active');
            });
            
            const option = document.querySelector(`[data-color-folder="${colorFolder}"]`);
            if (option) option.classList.add('active');

            updateCharacter();
        }

        // Update character
        async function updateCharacter() {
            if (!currentPart || currentItem === null || !currentColor) return;

            const part = currentPart.part;
            const sortOrder = part.x * 1000 + currentPart.index;

            characterLayers[currentPart.index] = {
                folderName: part.folder,
                color: currentColor,
                colorIndex: currentColorIndex,
                itemNumber: currentItem,
                sortOrder: sortOrder
            };

            renderCharacter();
        }

        // Render character
        async function renderCharacter() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Sort by sortOrder (X value determines layer order)
            const sortedLayers = Object.values(characterLayers).sort((a, b) => a.sortOrder - b.sortOrder);

            for (const layer of sortedLayers) {
                const { folderName, color, itemNumber } = layer;

                // Determine image path
                let imagePath;
                if (color === 'default' || !color) {
                    // No color folder, image in root
                    imagePath = `${KIT_PATH}${folderName}/${itemNumber}.png`;
                } else {
                    // Image in color subfolder
                    imagePath = `${KIT_PATH}${folderName}/${color}/${itemNumber}.png`;
                }

                try {
                    const img = await loadImage(imagePath);
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                } catch (error) {
                    console.error(`Failed to load: ${imagePath}`);
                }
            }
        }

        // Load image helper
        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        // Export character
        function exportCharacter() {
            const link = document.createElement('a');
            link.download = 'my-character.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        // Reset character
        function resetCharacter() {
            characterLayers = {};
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            currentPart = null;
            currentItem = null;
            currentColor = null;

            document.querySelectorAll('.nav-icon, .item-option, .color-option').forEach(el => {
                el.classList.remove('active');
            });

            document.getElementById('item-grid').innerHTML = '';
            document.getElementById('color-grid').innerHTML = '';
            document.getElementById('current-part-name').textContent = 'Ch·ªçn m·ªôt b·ªô ph·∫≠n';
        }

        // Randomize character
        async function randomizeCharacter() {
            if (!kitStructure || kitStructure.length === 0) return;

            // Randomize each part
            for (let partIndex = 0; partIndex < kitStructure.length; partIndex++) {
                const part = kitStructure[partIndex];
                if (part.items_count === 0) continue;

                // 85% chance to select an item, 15% chance to skip (None)
                if (Math.random() < 0.15) {
                    delete characterLayers[partIndex];
                    continue;
                }

                const itemNumber = Math.floor(Math.random() * part.items_count) + 1;
                const colors = part.colors.length > 0 ? part.colors : ['default'];
                const colorIdx = Math.floor(Math.random() * colors.length);
                const selectedColor = colors[colorIdx];

                const sortOrder = part.x * 1000 + partIndex;

                characterLayers[partIndex] = {
                    folderName: part.folder,
                    color: selectedColor,
                    colorIndex: colorIdx,
                    itemNumber: itemNumber,
                    sortOrder: sortOrder
                };
            }

            renderCharacter();

            // Refresh UI if a part is currently selected
            if (currentPart) {
                selectPart(currentPart.index, currentPart.part);
            }
        }

        // Prompt zip kit command
        async function promptZipKit() {
            if (!confirm(`B·∫°n c√≥ mu·ªën t·∫£i xu·ªëng to√†n b·ªô folder b·ªô s∆∞u t·∫≠p "${CURRENT_KIT_FOLDER}" th√†nh file .zip kh√¥ng?`)) return;
            
            try {
                // Show loading message
                const loadingMsg = document.createElement('div');
                loadingMsg.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);color:white;padding:20px;border-radius:10px;z-index:9999;';
                loadingMsg.textContent = 'ƒêang t·∫°o file ZIP...';
                document.body.appendChild(loadingMsg);

                const response = await fetch('/api/zip_kit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ kit: CURRENT_KIT_FOLDER })
                });

                // Remove loading message
                document.body.removeChild(loadingMsg);

                if (response.ok) {
                    // Get the blob from response
                    const blob = await response.blob();
                    
                    // Create download link
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${CURRENT_KIT_FOLDER}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    
                    // Cleanup
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    
                    alert('File ZIP ƒë√£ ƒë∆∞·ª£c t·∫£i xu·ªëng!');
                } else {
                    const result = await response.json();
                    alert("L·ªói: " + (result.message || 'Kh√¥ng th·ªÉ t·∫°o file ZIP'));
                }
            } catch (error) {
                alert("Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn Server. B·∫°n c√≥ ƒëang ch·∫°y app_server.py kh√¥ng?");
                console.error(error);
            }
        }

        // Prompt delete part command
        async function promptDeletePart() {
            if (!currentPart) return;
            const yIndex = currentPart.index + 1;
            
            if (!confirm(`B·∫°n c√≥ mu·ªën X√ìA Vƒ®NH VI·ªÑN b·ªô ph·∫≠n "${currentPart.part.name}" (Folder index ${currentPart.folderName})?\n\nL∆∞u √Ω: H√†nh ƒë·ªông n√†y s·∫Ω t·ª± ƒë·ªông ƒë·ªïi t√™n c√°c folder ph√≠a sau ƒë·ªÉ l·∫•p kho·∫£ng tr·ªëng.`)) return;
            
            try {
                const response = await fetch('/api/delete_part', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ kit: CURRENT_KIT_FOLDER, y: yIndex })
                });
                const result = await response.json();
                if (result.success) {
                    alert("ƒê√£ x√≥a xong! Trang web s·∫Ω t·ª± ƒë·ªông t·∫£i l·∫°i.");
                    location.reload();
                } else {
                    alert("L·ªói: " + result.message);
                }
            } catch (error) {
                alert("Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn Server. B·∫°n c√≥ ƒëang ch·∫°y app_server.py kh√¥ng?");
                console.error(error);
            }
        }

        // Initialize on load
        loadKitsList();
    </script>
</body>

</html>